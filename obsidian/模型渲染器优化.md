---
theme: seriph
background: https://zhongxuyang.github.io/blog/assets/DSCF3785.714143b6.jpg
class: text-center
highlighter: shiki
lineNumbers: false
info: |
  ## Slidev Starter Template
  Presentation slides for developers.

  Learn more at [Sli.dev](https://sli.dev)
drawings:
  persist: false
transition: slide-left
title: 模型渲染器优化
fonts:
  sans: Noto Serif SC
  serif: Robot Slab
  mono: Fira Code
---


<style>
@keyframes hue {
  0% {
    -webkit-filter: hue-rotate(0deg);
    filter: hue-rotate(0deg);
  }

  to {
    -webkit-filter: hue-rotate(-1turn);
    filter: hue-rotate(-1turn);
  }
}

h1, h2, h3 {
  background-color: #2B90B6;
  background-image: linear-gradient(90deg, #01916d 10%, #018463 20%);
  background-size: 100%;
  -webkit-background-clip: text;
  -moz-background-clip: text;
  -webkit-text-fill-color: transparent;
  -moz-text-fill-color: transparent;
  text-shadow: 0px 0px 30px #018463;
  font-weight: bold !important;
  /* animation: hue 5s linear infinite alternate; */
}
.smaller{
  font-size: 0.8em;
}
.remark {
  font-size: 0.8em;
  opacity: 0.65;
}
.center{
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
}
</style>

# **模型渲染器优化**

#### 杨中旭

<p class="remark">

[Preview](http://localhost:6006/?path=/story/example-erg--base)

</p>

<!--
大家好，今天给大家分享一下模型渲染器的优化都做了哪些工作。

首先来看一下渲染器的功能都有哪些。
-->

---

## 主题

1. ⚙️ 工具变化

1. 🎨 设计缺陷
    - 🖌️ 画布
    - 🔄 数据更新机制
    - 📡 事件中心机制

3. 🛠️ 功能实现
    - 🖼️ Canvas
    - 🧩 Plugins
    - 📚 Typedoc

<!--
这是今天讲的主题范围。
-->

---
layout: image-right
image: https://zhongxuyang.github.io/blog/assets/96580014.1cb84cc5.jpg
---

## 1 **工具变化**


---

### 工具变化


|     | Before | After |
| --- | --- | --- |
| 语言 | js | ts |
| 构建工具 | webpack | vite |
| 模版示例 | webpack、html | storybook、vue |
| 文档生成 | 手写 | typedoc |

<!--
首先给大家介绍一下工具上的改变。
-->

---
layout: image-right
image: https://zhongxuyang.github.io/blog/assets/DSCF3104.1b8c9731.jpg
---

## 2 **设计缺陷**

<!--
接下来是关于优化前后的对比。
-->

---

### 画布 - Canvas

|     | Before | After |
| --- | --- | --- |
| 写法 | 与渲染器代码掺杂在一起 | Canvas类 |
| 界限 | 有起始边界 | 无边界 |
| 背景 | 固定 | 可拓展、可视区渲染 |
| 滚动 | 依托滚动条 | 自托管 |
| 图层 | 缓存层、主视图层 | 缓存层、主视图层、[事件层](https://g6.antv.antgroup.com/zh/examples/performance/perf/#eva)、拓展层 |
<!-- | 更多 | - | EventCenter、viewTo、export | -->

<!--
首先是关于Canvas类的优化。

把画布的相关功能从渲染器抽离出来的好处是显而易见的，代码变得更加清晰，也方便多实例调用了。例如现在应用在模型和血缘两个渲染器中。


> 分层渲染

接下来主要介绍下分层渲染：
缓存层和主视图层可能比较好理解，那事件层和拓展层是什么呢？

事件视图层的作用：主要是参考antv的设计。在数据量巨大的场景中，事件频繁触发需要绘制全量数据性能消耗是巨大的，这时只绘制部分内容，其余主视图层作为背景图的作用，例如 Antv 中鼠标移动只在事件层绘制了hover实体，全量数据在事件层下方相当于背景图，参照：[antv](https://g6.antv.antgroup.com/zh/examples/performance/perf/#eva)
-->

---

### Canvas层级关系


<div class="layer-box">
  <div>缓存层</div>
  <div>主视图</div>
  <div>事件层</div>
  <div>拓展层</div>
</div>

<style>
@keyframes closeTo{
  0% {
    top: -60px;
    left: -80px;
  }
  100% {
    top: -20px;
    left: 0px;
  }
}
@keyframes rotate{
  0% {
    -webkit-filter: hue-rotate(0deg);
    filter: hue-rotate(0deg);
  }

  to {
    -webkit-filter: hue-rotate(-1turn);
    filter: hue-rotate(-1turn);
  }
}
.layer-box{
  position: relative;
  width: 400px;
  height: 250px;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  perspective: 800px;
}
.layer-box div{
  position: absolute;
  padding: 10px;
  width: 100%;
  height: 100%;
  border: 1px solid #f68084;
  background: rgba(122, 122, 122, 0.3);
  transform: rotateY(45deg);
  border-radius: 5px;
}
.layer-box div:nth-of-type(1){
  top: -60px;
  left: -80px;
  animation: closeTo 3s infinite alternate;
}
.layer-box div:nth-of-type(2){
  top: -20px;
  left: 0px;
  background-image: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
}
.layer-box div:nth-of-type(3){
  top: 20px;
  left: 80px;
  animation: rotate 3s infinite alternate;
  background-image: linear-gradient(-225deg, #473B7B80 0%, #3584A780 51%, #30D2BE80 100%);
}
.layer-box div:nth-of-type(4){
  top: 60px;
  left: 160px;
}
</style>

<!--
这是分层的关系示意图。

// 先介绍下各分层的作用 //


需要注意的是单纯依靠分层渲染依然不能解决所有渲染上的性能问题：

在一些情况下分层渲染是不能适用的，例如：在这些图层之间有着固定的上下层级，因此如果两/多个元素之间交互层叠，这时候分层就没办法满足了（这时候需要的是元素分组以及局部渲染，局部渲染很复杂。。。需要计算所有相邻元素的包围盒进行碰撞检测，确定最小的重绘范围，同时需要注意上下的层级关系的影响）。
-->

---

### 数据更新机制 - DataHandler

<br/>

<div style="display: grid; grid-template-columns: 1fr 1fr; grid-gap: 10px;">
  <div>
    <i>Before</i>
    <p>
      渲染器直接修改外部数据，外部通过 watch 原始数据的变化触发服务端保存等操作。
    </p>
  </div>

  <div>
    <i>After</i>
    <p>
      渲染器自身不修改原始数据，一切更新通过 EventCenter 通知外部操作。
    </p>
    <p class="remark">
      这种方式虽然逻辑更清晰了，但会造成外部需要挂载大量的监听，这显然是不太易用的。
      因此渲染器提供了 DataHandler 类用于接管原始数据，避免了在使用时需要挂载大量的监听及数据更新的代码的繁琐。
    </p>
  </div>
</div>

<!--
这次是这次重写比较重要的改动之一，修改了数据的更新机制。

原有的代码中，当页面发生交互时，渲染器会直接修改传递进来的数据，这导致对于修改原始数据的代码散落在程序的各个角落，首先这种写法是很混乱的。

其次外部想要获知这种修改，只能够监听原始数据，而watch又只能够感知到数据的变化，却不知道是具体的哪一个属性发生了怎样的变化。（如果想要定位到修改数据只能够diff，而修改又是每时每刻都在发生的，这显然不是很好的解决办法。）

在感受了上一个版本的痛点后，这次引入了 事件中心 - `EventCenter`用于通知外部更新数据（下一节会讲到`EventCenter`）。

主要思路就是渲染器自身不修改原始数据，一切更新通过 EventCenter 通知外部操作。

但这种方式虽然逻辑更清晰了，但会造成在使用时外部需要挂载大量的监听，这显然是不太易用的。

因此渲染器提供了可选的 DataHandler 类用于接管原始数据，避免了在使用时需要挂载大量的监听及数据更新的代码的繁琐。
-->

---

### 事件中心 - EventCenter

<br/>

<div style="display: grid; grid-template-columns: 1fr 1fr; grid-gap: 10px;">
  <div>
    <i>Before</i>
    
```ts {5-9,11}
const renderer = new Graph()

renderer.load({
  // ...
  externalFn: {
    addNode () {},
    delNode () {},
    addLine () {},
    delLine () {},
    // ...
  },
})
```
  </div>

  <div>
    <i>After</i>

```ts {4-8}
const renderer = new Graph({
  // ...
})

renderer.on(NodeEvent.New, (info) => {})
renderer.on(NodeEvent.Delete, (info) => {})
renderer.on(LineEvent.New, (info) => {})
renderer.on(NodeEvent.Delete, (info) => {})
// ...
```
  </div>
</div>

<!--
接下来对于事件的处理。这里可以看到引入`EventCenter`前后的事件挂载方式。

左侧修改前是在渲染器实例的load方法中传入externalFunction对象。

右侧修改后是取消了load函数，由实例.on监听的方式挂载事件。

从这段代码片段里大家能看出来，这样修改后会带来哪些好处吗？
-->

---

### 事件中心 - EventCenter

*Why?*

- 让代码更加简洁和模块化
- 数据与事件拆分，逻辑更清晰
- 可以将 `Graph` 类的实现与具体的外部函数解耦，从而提高代码的可维护性和可重用性
- 使用事件监听器可以实现更加灵活和可扩展的模式，可以动态地添加或删除事件监听器
  - 提供：`on`、 `once`、 `off`、 `emit` 函数
- 可以重复挂载

<!-- <p class="remark">
不要小看重复挂载带来的好处。例如：

- 前面提到的 `DataHandler` 就是依托于 `EventCenter` 的重复挂载实现的。
  <div class="remark">
  渲染器内部的 `dataHandler` 会首先监听到数据更新通知，这一层内部处理好数据，外部监听拿到的就是经过 `dataHandler` 处理的最新数据。
  </div>
</p> -->

<!--
#### 不要小看重复挂载带来的好处。例如：

- 前面提到的 `DataHandler` 就是依托于 `EventCenter` 的重复挂载实现的。

  渲染器内部的 `dataHandler` 会首先监听到数据更新通知，这一层内部处理好数据，外部监听拿到的就是经过 `dataHandler` 处理的最新数据。

#### 接下来仔细看一下 `emit` 方法。

在上一页的PPT中，有一种场景是改造前可用，改造后反而没办法适用了。

这个场景是：通过`externals`对象传入的钩子是一个函数，因此有一个确定的返回值，因此我们可以在例如：addNode函数里`return false`使流程abort（终止）执行。

但是改造后由于使用`on`监听可以挂载多个函数，这时的返回值就变得不再唯一确定，因而变的无法利用，如何处理这种情况呢？

大家有什么想法吗？

下一章节会讲到代码实现。
-->

---
layout: image-right
image: https://zhongxuyang.github.io/blog/assets/DSCF4089.81ad99e7.jpg
---

# 3 **功能实现**

<!--
设计缺陷部分到这里就结束了。
在第一次的开发过程中其实是难以照顾到很多细节，或者说一下就想到最优解的。在功能越加越多、代码越来越冗杂之后，重新回顾和优化代码，也是重新学习的、也是很有必要的过程。

接下来是功能实现部分。

这里介绍3个部分：
- 前面提到的EventCenter中如何根据外部返回值决定下一步操作
- 渲染器的撤销回退的实现
- 文档如何维护
-->

---

### EventCenter

<br/>

<div style="display: grid; grid-template-columns: 1fr 1fr; grid-gap: 10px;">
  <div>
    <i>Define</i>
<v-click>

</v-click>

```ts {1,3,5,13,15,16,19}
class EventCenter {
  // ...
  public emit(eventName: Event, ...options) {
    // ...
    const results = []
    for (
      let i = 0, len = listenersForEvent.length; 
      i < len; 
      i++
    ) {
      const result = 
        listenersForEvent[i].call(this, ...options)
      results.push(result)
    }
    // return this
    return results
  }
}
```
  </div>

  <div>
  <i>Usage</i>

```ts
// 触发
const beforeChangeResult = this.emit(Event.BeforeChange, target)

Promise.all(beforeChangeResult).then(() => {
  // do something...

  this.emit(Event.Change, target)
}).catch(() => {
  // abort
})
```

```ts
// 监听
graph.on(Event.BeforeChange, (target) => {
  // ...
  
  // 返回reject，由使用者接管创建流程（可在此处开始服务端创建）
  return Promise.reject()
})
```
  </div>
</div>

<!--
接下来看如何处理这种情景。

最初`EventCenter`的`emit`函数返回的是它本身即this（方便链式调用），但由于有了前面提到的需求，功能显然比方便更重要。

在Define代码里我们可以看到，首先在`EventCenter`的`emit`事件里收集了所有监听函数的返回值存到results数组，最后在emit函数里return抛出去。

外部接收results后使用 Promise.all 确保是否所有监听函数（可能会有异步）执行完毕。如果在监听函数return reject，我们则认为这个流程无法通过，也就是停止后续操作。

由此就实现了前面提到的功能：让使用者异步/可选择的决定是否继续操作。
-->

---

### Plugins - History

<br />

<div style="display: grid; grid-template-columns: 1fr 1fr; grid-gap: 10px;">
  <div>

```ts {1,7,9-18,20}
class History {
  private history: Action[]
  private currentIndex: number
  private maxSteps = 20
  private compressTime = 20

  public push(action: Action | Action['reverse']) {
    // ...
    const prevAction = this.history[this.currentIndex]
    if (this.canMerge(prevAction, action)) {
      const cachePrevReverse = prevAction.reverse
      prevAction.reverse = () => {
        ;(action as Action).reverse()
        cachePrevReverse()
      }
      prevAction.time = action.time
      return this
    }
    // ...
  }
```
  </div>

  <div>

```ts {1-4,13-15}
  private canMerge(
    prevAction: Action, 
    nextAction: Action,
  ) {
    const timeDistance = 
      Number(nextAction.time) - Number(prevAction.time)
    const ifTimeLegal = 
      timeDistance <= this.compressTime
    const ifSameTarget = 
      prevAction.targetId === nextAction.targetId
    const ifSameOperation =
      prevAction.operationType === nextAction.operationType
    return 
      ifTimeLegal && ifSameTarget && ifSameOperation
  }

  // ...
}
```
  </div>
</div>

<!--
History是实现历史记录类，主要实现撤销、回退功能。

从代码里可以看出一共有4个状态：
- history数组用于缓存每一步操作，包含每一步的：操作内容、操作人、事件戳。
- currentIndex用于指示当前光标位置，触发撤销和回退时移动此指针。
- maxSteps用于配置最大缓存步数。
- compressTime用于配置可压缩时间。也就是说每一步操作入栈前会根据事件戳与上一步操作的时间戳匹配，如果时间差小于compressTime，那么会把这两步合并为一步操作。

// 开始过代码

解释下为什么这里存储的是reverse，而不是修改数据：
 *  在画布中一步操作一般会影响多个相关的数据，例如：节点坐标的改变会同步修改所有与之相关的连线。
 *  为了避免这种关联性带来的数据修改复杂性，不如直接缓存逆向执行的函数，避免了处理相关数据的繁琐。
-->

---

### 文档生成

*使用 `typedoc` : [https://typedoc.org/](https://typedoc.org/)*

<br/>

- 为什么提到这个？
- 使用 Typescript 还需要文档吗？

<!-- <div style="display: grid; grid-template-columns: 1fr 1fr; grid-gap: 10px;">
  <div>
    <i>为什么提到这个？</i>
    <p class="remark">
      文档维护是个很头疼的事情。
      <br/>
      很多时候一些细碎的修改很可能忘记更新文档，久而久之文档就变得和真实程序差异巨大。
      <br/>
      而当程序大规模的重构时，重写文档就更是巨大的工作量，让人望而却步。
    </p>
  </div>

  <div>
    <i>使用 Typescript 还需要文档吗？</i>
    <p class="remark">
      虽然 `typedoc` 是基于 `TypeScript` 类型及备注内容生成的文档。但使用 `TypeScript` 不意味着不需要文档。 
      <br/>
      `typedoc` 可以自动为 `TS` 代码生成易读的API文档，方便其他开发者 `quick start` 和理解代码。
      <br/>
      除了生成 `.md` 方便在 `github/npm` 中预览外，生成的页面也会更加方便搜索。
    </p>
  </div>
</div> -->

<!--
- 为什么提到这个？

文档维护是个很头疼的事情。

很多时候一些细碎的修改很可能忘记更新文档，久而久之文档就变得和真实程序差异巨大。

而当程序大规模的重构时，重写文档就更是巨大的工作量，让人望而却步。

这时候自动生成文档的作用就体现出来了，可以在每次发版/通过commit hooks配置自动生成文档。

- 使用 Typescript 还需要文档吗？

虽然typedoc是基于TypeScript类型及备注内容生成的文档。但使用TypeScript不意味着不需要文档。 

typedoc可以自动为TS代码生成易读的API文档，有哪些功能通过文档目录就可以方便的知道，也方便其他开发者quick start和理解代码。

- 生成的.markdown文档可以便于在github/npm中预览。
- 生成的html页面也会更加方便预览和搜索查找。

// 看一下生成文档的样子
-->

---

<div class="center">
  
  ## Thanks

  <p class="remark">
  
  [Documentations](https://sli.dev) · [GitHub](https://github.com/ZhongxuYang) · [Code](https://gitlab.jinxin.dev/ej-dr/infrastructure/infra_front/ej-erg-renderer)
  
  </p>

</div>

<!--
今天分享的内容就结束了。大家有什么问题想问吗？

这次分享内容使用Anthony fu的slidev /sli'dæv/制作，很简单，写markdown文件就好，有需要的可以尝试下。
-->